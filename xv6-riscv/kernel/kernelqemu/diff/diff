###############################################
../bio.c
###############################################
24a25
> #include "disk.h"
99c100
<     virtio_disk_rw(b, 0);
---
> 	spi_rb(b->blockno,b->data);
111c112
<   virtio_disk_rw(b, 1);
---
>   spi_wb(b->blockno,b->data);

###############################################
../kernel.ld
###############################################
11,13c11,13
< 
<   .text : {
<     *(.text .text.*)
---
>   .text :
>   {
>     *(.text)
15d14
<     _trampoline = .;
17,19d15
<     . = ALIGN(0x1000);
<     ASSERT(. - _trampoline == 0x1000, "error: trampoline larger than one page");
<     PROVIDE(etext = .);
22,27c18,19
<   .rodata : {
<     . = ALIGN(16);
<     *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */
<     . = ALIGN(16);
<     *(.rodata .rodata.*)
<   }
---
>   . = ALIGN(0x1000);
>   PROVIDE(etext = .);
28a21,23
>   /*
>    * make sure end is after data and bss.
>    */
30,33c25
<     . = ALIGN(16);
<     *(.sdata .sdata.*) /* do not need to distinguish this from .data */
<     . = ALIGN(16);
<     *(.data .data.*)
---
>     *(.data)
35d26
< 
37,40c28,30
<     . = ALIGN(16);
<     *(.sbss .sbss.*) /* do not need to distinguish this from .bss */
<     . = ALIGN(16);
<     *(.bss .bss.*)
---
>     *(.bss)
>     *(.sbss*)
>      PROVIDE(end = .);
42,43d31
< 
<   PROVIDE(end = .);

###############################################
../main.c
###############################################
5a6
> #include "disk.h"
30c31,32
<     virtio_disk_init(); // emulated hard disk
---
> 	spi_init();
> //    virtio_disk_init(); // emulated hard disk

###############################################
../param.h
###############################################
2c2
< #define NCPU          2  // maximum number of CPUs
---
> #define NCPU          1  // maximum number of CPUs
8,9c8,9
< #define MAXARG        8  // max exec arguments
< #define MAXOPBLOCKS   8  // max # of blocks any FS op writes
---
> #define MAXARG       16  // max exec arguments
> #define MAXOPBLOCKS  16  // max # of blocks any FS op writes
12c12
< #define FSSIZE       2000  // size of file system in blocks
---
> #define FSSIZE       80000  // size of file system in blocks

###############################################
../plic.c
###############################################
16c16
<   *(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
---
>   //*(uint32*)(PLIC + VIRTIO0_IRQ*4) = 1;
26c26
<   *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ) | (1 << VIRTIO0_IRQ);
---
>   *(uint32*)PLIC_SENABLE(hart) = (1 << UART0_IRQ);// | (1 << VIRTIO0_IRQ);

###############################################
../riscv.h
###############################################
1,2d0
< #ifndef __ASSEMBLER__
< 
26a25,31
> static inline uint32
> r_sscratch()
> {
>   uint32 x;
>   asm volatile("csrr %0, sscratch" : "=r" (x) );
>   return x;
> }
116c121
< // supervisor exception program counter, holds the
---
> // machine exception program counter, holds the
186,198d190
< // Physical Memory Protection
< static inline void
< w_pmpcfg0(uint32 x)
< {
<   asm volatile("csrw pmpcfg0, %0" : : "r" (x));
< }
< 
< static inline void
< w_pmpaddr0(uint32 x)
< {
<   asm volatile("csrw pmpaddr0, %0" : : "r" (x));
< }
< 
201d192
< 
202a194
> 
218a211,217
> // Supervisor Scratch register, for early trap handler in trampoline.S.
> static inline void 
> w_sscratch(uint32 x)
> {
>   asm volatile("csrw sscratch, %0" : : "r" (x));
> }
> 
270a270
>   w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);
297c297
< // read and write tp, the thread pointer, which xv6 uses to hold
---
> // read and write tp, the thread pointer, which holds
329,332d328
< typedef uint32 pte_t;
< typedef uint32 *pagetable_t; // 1024 PTEs
< 
< #endif // __ASSEMBLER__
344c340
< #define PTE_U (1L << 4) // user can access
---
> #define PTE_U (1L << 4) // 1 -> user can access
353c349
< // extract the three 10-bit page table indices from a virtual address.
---
> // extract the TWO (not three, only on 64 bit) 10-bit page table indices from a virtual address.
361a358,360
> //#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
> 
> // HACK FOR 32 bit
362a362,364
> 
> typedef uint32 pte_t;
> typedef uint32 *pagetable_t; // 1024 PTEs

###############################################
../start.c
###############################################
13,14c13,14
< // a scratch area per CPU for machine-mode timer interrupts.
< uint32 timer_scratch[NCPU][6];
---
> // scratch area for timer interrupt, one per CPU.
> uint32 mscratch0[NCPU * 32];
24c24
<   unsigned long x = r_mstatus();
---
>   unsigned int x = r_mstatus();
39,44d38
<   w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);
< 
<   // configure Physical Memory Protection to give supervisor mode
<   // access to all of physical memory.
<   //w_pmpaddr0(0x3fffffffffffffull);
<   //w_pmpcfg0(0xf);
57,59c51,52
< // arrange to receive timer interrupts.
< // they will arrive in machine mode at
< // at timervec in kernelvec.S,
---
> // set up to receive timer interrupts in machine mode,
> // which arrive at timervec in kernelvec.S,
69c62
<   int interval = 1000000; // cycles; about 1/10th second in qemu.
---
>   uint32 interval =  1000000; // cycles; about 1/10th second in qemu.
73,76c66,69
<   // scratch[0..2] : space for timervec to save registers.
<   // scratch[3] : address of CLINT MTIMECMP register.
<   // scratch[4] : desired interval (in cycles) between timer interrupts.
<   uint32 *scratch = &timer_scratch[id][0];
---
>   // scratch[0..3] : space for timervec to save registers.
>   // scratch[4] : address of CLINT MTIMECMP register.
>   // scratch[5] : desired interval (in cycles) between timer interrupts.
>   uint32 *scratch = &mscratch0[32 * id];

###############################################
../swtch.S
###############################################
3c3
< #   void swtch(struct context *old, struct context *new);
---
> #   void swtch(struct context *olw, struct context *new);
5,6c5
< # Save current registers in old. Load from new.	
< 
---
> # Save current registers in olw. Load from new.	

###############################################
../syscall.c
###############################################

###############################################
../trampoline.S
###############################################
0a1,2
> 	#
>         # code to switch between user and kernel space.
2,10c4,9
<         # low-level code to handle traps from user space into
<         # the kernel, and returns from kernel to user.
<         #
<         # the kernel maps the page holding this code
<         # at the same virtual address (TRAMPOLINE)
<         # in user and kernel space so that it continues
<         # to work when it switches page tables.
<         # kernel.ld causes this code to start at 
<         # a page boundary.
---
>         # this code is mapped at the same virtual address
>         # (TRAMPOLINE) in user and kernel space so that
>         # it continues to work when it switches page tables.
> 	#
> 	# kernel.lw causes this to be aligned
>         # to a page boundary.
13,16c12
< #include "riscv.h"
< #include "memlayout.h"
< 
< .section trampsec
---
> 	.section trampsec
28,36c24,26
< 
<         # save user a0 in sscratch so
<         # a0 can be used to get at TRAPFRAME.
<         csrw sscratch, a0
< 
<         # each process has a separate p->trapframe memory area,
<         # but it's mapped to the same virtual address
<         # (TRAPFRAME) in every process's user page table.
<         li a0, TRAPFRAME
---
>         # sscratch points to where the process's p->tf is
>         # mapped into user space, at TRAPFRAME.
>         #
37a28,31
> 	# swap a0 and sscratch
>         # so that a0 is TRAPFRAME
>         csrrw a0, sscratch, a0
> 
70c64
< 	# save the user a0 in p->trapframe->a0
---
> 	# save the user a0 in p->tf->a0
74c68
<         # initialize kernel stack pointer, from p->trapframe->kernel_sp
---
>         # restore kernel stack pointer from p->tf->kernel_sp
77c71
<         # make tp hold the current hartid, from p->trapframe->kernel_hartid
---
>         # make tp holw the current hartid, from p->tf->kernel_hartid
80c74
<         # load the address of usertrap(), from p->trapframe->kernel_trap
---
>         # load the address of usertrap(), p->tf->kernel_trap
83,84c77
< 
<         # fetch the kernel page table address, from p->trapframe->kernel_satp.
---
>         # restore kernel page table from p->tf->kernel_satp
86,91d78
< 
<         # wait for any previous memory operations to complete, so that
<         # they use the user page table.
<         sfence.vma zero, zero
< 
<         # install the kernel page table.
93,94d79
< 
<         # flush now-stale user entries from the TLB.
96a82,84
>         # a0 is no longer valid, since the kernel page
>         # table does not specially map p->tf.
> 
102,103c90
<         # userret(pagetable)
<         # called by usertrapret() in trap.c to
---
>         # userret(TRAPFRAME, pagetable)
105c92,94
<         # a0: user page table, for satp.
---
>         # usertrapret() calls here.
>         # a0: TRAPFRAME, in user page table.
>         # a1: user page table, for satp.
108,109c97
<         sfence.vma zero, zero
<         csrw satp, a0
---
>         csrw satp, a1
112c100,103
<         li a0, TRAPFRAME
---
>         # put the saved user a0 in sscratch, so we
>         # can swap it with our a0 (TRAPFRAME) in the last step.
>         lw t0, 56(a0)
>         csrw sscratch, t0
146,147c137,138
< 	# restore user a0
<         lw a0, 56(a0)
---
> 	# restore user a0, and save TRAPFRAME in sscratch
>         csrrw a0, sscratch, a0

###############################################
../trap.c
###############################################
129c129
<   ((void (*)(uint32))trampoline_userret)(satp);
---
>   ((void (*)(uint32,uint32))trampoline_userret)(TRAPFRAME,satp);
191,192c191,192
<     } else if(irq == VIRTIO0_IRQ){
<       virtio_disk_intr();
---
> //    } else if(irq == VIRTIO0_IRQ){
> //      virtio_disk_intr();

###############################################
../uart.c
###############################################
62c62
<   WriteReg(0, 0x03);
---
>   WriteReg(0, 32000000/115200 & 0xff);
65c65
<   WriteReg(1, 0x00);
---
>   WriteReg(1, 32000000/115200 >> 8);
69c69
<   WriteReg(LCR, LCR_EIGHT_BITS);
---
>   WriteReg(LCR, 0x00);
72c72
<   WriteReg(FCR, FCR_FIFO_ENABLE | FCR_FIFO_CLEAR);
---
>   WriteReg(FCR, 0x07);

###############################################
../vm.c
###############################################
31c31
<   kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
---
>   kvmmap(kpgtbl, 0x20000000, 0x20000000, PGSIZE, PTE_R | PTE_W);

